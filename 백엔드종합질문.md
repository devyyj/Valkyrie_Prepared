* 프로세스(Process)란 무엇인가요?
* 쓰레드(Thread)란 무엇인가요?
* 멀티쓰레드(Multi-thread)와 멀티프로세스(Multi-process)의 차이점은 무엇인가요?
* Java에서 Garbage Collection이란 무엇인가요?
* Java에서 오버로딩과 오버라이딩의 차이점은 무엇인가요?
* Java에서 인터페이스와 추상 클래스의 차이점은 무엇인가요?
* Java에서 JDBC란 무엇인가요?
* Java에서 JPA(Java Persistence API)란 무엇인가요?
* 스프링 프레임워크란 무엇이며, 어떤 장점이 있나요?
* DI (의존성 주입)란 무엇인가요?
* AOP (관점 지향 프로그래밍)란 무엇인가요?
* 스프링 프레임워크에서 POJO는 무엇인가요?
* RESTful API란 무엇인가요?
* 쿠키(Cookie)와 세션(Session)의 차이점은 무엇인가요?
* 인증(Authentication)과 권한 부여(Authorization)의 차이점은 무엇인가요?
* CI/CD(Continuous Integration/Continuous Deployment)란 무엇인가요?
* SQL JOIN의 종류에 대해서 설명해주세요.
* SQL과 NoSQL의 차이점은 무엇인가요?
* 데이터베이스(Database) 정규화(Normalization)란 무엇인가요?
* 인덱스(Index)란 무엇인가요?
* 트랜잭션(Transaction)이란 무엇인가요?
* ORM(Object-Relational Mapping)이란 무엇인가요?
* 캐싱(Caching)이란 무엇인가요?
* JWT(Json Web Token)란 무엇인가요?
* 동기(Synchronous)와 비동기(Asynchronous)의 차이점은 무엇인가요?
* 웹 서버(Web Server)와 애플리케이션 서버(Application Server)의 차이점은 무엇인가요?

## 컴퓨터 사이언스

### 프로세스(Process)란 무엇인가요?

프로세스는 컴퓨터에서 실행 중인 프로그램을 의미합니다. 실행 중인 프로그램은 메모리에 올라가서 CPU에 의해 실행되며, 이러한 실행 중인 프로그램을 프로세스라고 부릅니다. 프로세스는 운영체제(OS)에 의해 관리되며,
프로세스마다 자신의 주소 공간, 메모리, 입출력, 파일 등의 자원을 가지고 있습니다. 또한, 하나의 프로그램이 여러 개의 프로세스로 분리되어 실행될 수도 있습니다.

### 쓰레드(Thread)란 무엇인가요?

쓰레드는 프로세스 내에서 실행되는 작업의 단위입니다. 쓰레드는 프로세스 내에서 자원을 공유하면서 동시에 실행될 수 있습니다. 하나의 프로세스에서 여러 개의 쓰레드를 생성하고 관리할 수 있으며, 각각의 쓰레드는
독립적으로 실행될 수 있습니다. 쓰레드는 하나의 프로세스 내에서 작업을 분리하여 병렬적으로 실행함으로써 시스템의 성능을 향상시킬 수 있습니다.

### 멀티쓰레드(Multi-thread)와 멀티프로세스(Multi-process)의 차이점은 무엇인가요?

멀티쓰레드와 멀티프로세스는 모두 여러 작업을 동시에 처리할 수 있는 기술입니다. 그러나 두 기술은 다음과 같은 차이점이 있습니다.

* 자원 공유: 멀티쓰레드는 하나의 프로세스 내에서 여러 쓰레드가 자원을 공유하여 사용합니다. 반면 멀티프로세스는 서로 다른 프로세스끼리 자원을 공유할 수 없습니다.
* 컨텍스트 스위칭(Context Switching): 멀티쓰레드는 쓰레드 간의 전환 시에 컨텍스트 스위칭(Context Switching)이 일어나며, 이는 비교적 빠른 속도로 일어납니다. 반면 멀티프로세스는
  프로세스 간의 전환 시에도 컨텍스트 스위칭이 일어나며, 이는 상대적으로 느린 속도로 일어납니다.
* 메모리 사용: 멀티쓰레드는 하나의 프로세스 내에서 여러 쓰레드가 메모리를 공유하여 사용하기 때문에, 메모리 사용량이 비교적 적습니다. 반면 멀티프로세스는 각각의 프로세스가 독립적으로 메모리를 사용하기 때문에,
  메모리 사용량이 많을 수 있습니다.
* 프로그래밍 복잡도: 멀티쓰레드는 하나의 프로세스 내에서 쓰레드를 생성하고 관리하기 때문에, 프로그래밍이 비교적 간단합니다. 반면 멀티프로세스는 서로 다른 프로세스끼리 자원을 공유하지 않으므로, 프로그래밍이 비교적
  복잡합니다.

## 자바

### Java에서 Garbage Collection이란 무엇인가요?

Garbage Collection은 자바에서 자동 메모리 관리를 위한 기능입니다.
Garbage Collector는 JVM에서 동작하며, 더 이상 사용되지 않는 객체를 자동으로 제거합니다.
이를 통해 개발자는 메모리 관리에 대한 부담을 덜 수 있으며, 더욱 안정적인 코드를 작성할 수 있습니다.

### Java에서 오버로딩과 오버라이딩의 차이점은 무엇인가요?

오버로딩(Overloading)은 같은 이름의 메소드를 다른 매개변수를 가지도록 여러 번 정의하는 것입니다.
오버라이딩(Overriding)은 부모 클래스의 메소드를 자식 클래스에서 재정의하는 것입니다.
즉, 오버로딩은 같은 이름의 다른 메소드를 만드는 것이고, 오버라이딩은 상속받은 메소드를 다시 정의하는 것입니다.

### Java에서 인터페이스와 추상 클래스의 차이점은 무엇인가요?

추상클래스(Abstract Class)와 인터페이스(Interface)는 모두 추상화된 개념을 나타내는 기술입니다. 하지만 두 기술은 다음과 같은 차이점이 있습니다.

* 구현 방법: 추상클래스는 일반 클래스와 마찬가지로 필드, 메서드, 생성자 등을 가질 수 있으며, 추상메서드를 포함할 수 있습니다. 반면 인터페이스는 메서드와 상수 필드만을 가질 수 있으며, 모든 메서드는
  추상메서드입니다.
* 다중 상속: 추상클래스는 단일 상속만을 지원합니다. 즉, 하나의 클래스만 상속받을 수 있습니다. 반면 인터페이스는 다중 상속을 지원합니다. 즉, 여러 인터페이스를 상속받을 수 있습니다.
* 구현 강제: 추상클래스에서는 추상메서드를 선언하더라도 일반 메서드를 가질 수 있으며, 하위 클래스에서 반드시 구현할 필요가 없는 메서드를 가질 수 있습니다. 반면 인터페이스에서는 모든 메서드가 추상메서드이므로,
  하위 클래스에서 반드시 구현해야 합니다.
* 목적: 추상클래스는 하위 클래스에서 공통적인 기능을 구현하고 상속 계층을 구성하는 데 사용됩니다. 반면 인터페이스는 클래스 간의 상호작용을 위한 규약을 정의하고, 다중 상속을 지원하여 유연한 구조를 구성하는 데
  사용됩니다.
* 생성자: 추상클래스는 생성자를 가질 수 있으며, 하위 클래스에서 상위 클래스의 생성자를 호출하여 초기화할 수 있습니다. 반면 인터페이스는 생성자를 가질 수 없으며, 인터페이스를 구현한 클래스에서 직접 초기화해야
  합니다.

### Java에서 JDBC란 무엇인가요?

JDBC(Java Database Connectivity)는 자바에서 데이터베이스에 접속하기 위한 API입니다.
JDBC를 사용하면 자바에서 다양한 데이터베이스에 접속하여 데이터를 조회, 수정, 삭제할 수 있습니다.
JDBC는 데이터베이스 벤더에서 제공하는 드라이버를 사용하여 데이터베이스와 연결하며, 자바 애플리케이션과 데이터베이스 간의 통신을 담당합니다.

### Java에서 JPA(Java Persistence API)란 무엇인가요?

JPA(Java Persistence API)는 자바 언어에서 객체를 데이터베이스에 저장하고 관리할 수 있는 API입니다. JPA는 ORM(Object-Relational Mapping)을 구현하는 기술로, 객체와
데이터베이스 간의 매핑을 자동으로 처리하여 개발자가 SQL 쿼리를 직접 작성하지 않아도 됩니다.

JPA를 사용하면 객체와 데이터베이스 간의 매핑 작업을 알아서 처리해주므로, 개발자는 비즈니스 로직에 집중할 수 있습니다. 또한 JPA는 데이터베이스의 변경에 대한 처리도 자동으로 처리해주므로, 데이터베이스의
스키마를 변경할 때도 쉽게 대처할 수 있습니다.

JPA는 ORM 기술의 표준으로 Java EE 표준 스펙에 포함되어 있으며, 대표적인 구현체로는 Hibernate, EclipseLink, OpenJPA 등이 있습니다.

## 스프링 프레임워크

### 스프링 프레임워크란 무엇이며, 어떤 장점이 있나요?

스프링 프레임워크(Spring Framework)는 자바 기반의 오픈 소스 애플리케이션 프레임워크입니다. 스프링은 애플리케이션 개발에 필요한 많은 기능을 제공하며, 웹 개발, 데이터베이스 연동, 트랜잭션 처리, 보안
처리 등에 대한 다양한 모듈을 제공합니다. 스프링은 DI (의존성 주입), AOP (관점 지향 프로그래밍), POJO (Plain Old Java Object), MVC (Model-View-Controller)
등의 개념을 활용하여 객체 지향적인 개발을 지원합니다.

스프링 프레임워크의 주요 장점은 다음과 같습니다.

- 모듈성: 스프링은 각각의 모듈이 독립적으로 동작하므로, 필요한 모듈만 가져와 사용할 수 있습니다.
- 높은 확장성: 스프링은 확장성이 높기 때문에 대규모 애플리케이션에도 적용이 가능합니다.
- DI, AOP, POJO 지원: 스프링은 DI, AOP, POJO 개념을 활용하여 유지보수성이 높은 객체 지향적인 개발이 가능합니다.
- 트랜잭션 처리: 스프링은 트랜잭션 처리를 위한 기능을 제공하여 데이터베이스 연동 애플리케이션 개발을 간편하게 만듭니다.
- 보안: 스프링은 보안 처리를 위한 기능을 제공하여 애플리케이션 보안을 강화할 수 있습니다.
- 테스트 지원: 스프링은 단위 테스트와 통합 테스트를 위한 기능을 제공하여 안정적인 애플리케이션 개발을 지원합니다.

### DI (의존성 주입)란 무엇인가요?

DI(Dependency Injection, 의존성 주입)는 객체지향 프로그래밍에서 객체 간의 의존성을 외부에서 설정하도록 만드는 설계 패턴입니다. 즉, 객체가 필요로 하는 의존성 객체를 직접 생성하지 않고,
외부에서 주입받아 사용합니다.

DI 패턴은 객체 간의 결합도를 낮추고 유지보수성을 높이는데 큰 도움을 줍니다. 객체가 직접 의존하는 객체를 생성하는 것이 아니라, 외부에서 주입받아 사용하므로 객체 간의 결합도가 낮아지며, 테스트나 기능 변경
시에도 유연하게 대처할 수 있습니다.

DI 패턴은 대표적으로 세 가지 방법으로 구현됩니다.

* 생성자 주입(Constructor Injection): 의존성 객체를 객체 생성자의 인자로 전달받습니다.
* 필드 주입(Field Injection): 의존성 객체를 인스턴스 변수로 직접 선언하고, 어노테이션을 이용하여 주입합니다.
* 메서드 주입(Method Injection): 의존성 객체를 인스턴스 메서드의 인자로 전달받습니다.

### AOP (관점 지향 프로그래밍)란 무엇인가요?

AOP(Aspect-Oriented Programming, 관점 지향 프로그래밍)은 객체지향 프로그래밍의 한 종류로, 코드의 횡단 관심사(Cross-Cutting Concerns)를 모듈화하고 분리하여 재사용성과
유지보수성을 높이는 기술입니다. 코드의 횡단 관심사란, 여러 모듈에서 공통적으로 발생하는 문제로, 예를 들어 로깅, 예외 처리, 트랜잭션 관리 등이 있습니다.

AOP는 횡단 관심사를 별도의 모듈로 분리하고, 이를 주요 비즈니스 로직 모듈과 결합하여 사용합니다. 이를 위해 AOP는 주요 비즈니스 로직 모듈과 횡단 관심사 모듈을 각각 Aspect(관점)이라는 단위로 분리하고,
이를 조합하여 하나의 애플리케이션을 구성합니다. AOP를 이용하면 관심사 모듈을 변경하더라도 주요 비즈니스 로직 모듈에 영향을 주지 않으므로, 유지보수성이 높아집니다.

### 스프링 프레임워크에서 POJO는 무엇인가요?

스프링 프레임워크에서 POJO(Plain Old Java Object)는 스프링의 핵심 개념 중 하나입니다. 스프링은 POJO를 기반으로 한 IoC(Inversion of Control)와 DI(Dependency
Injection)를 지원하여, 애플리케이션을 개발하는 데 큰 도움을 줍니다.

스프링에서 POJO는 인터페이스를 구현하거나, 특정한 클래스를 상속받지 않은 순수한 자바 객체를 뜻합니다. 이러한 POJO를 이용하여 스프링에서는 객체간의 의존성을 줄이고, 느슨한 결합(Loose Coupling)을
구현하여 유지보수성과 확장성을 높일 수 있습니다.

스프링에서 POJO는 다음과 같은 특징을 가집니다.

* 인터페이스나 추상 클래스를 상속받지 않음
* 특정한 라이브러리나 프레임워크에 의존하지 않음
* 일반적인 자바 객체로, 단순하고 가독성이 좋음
* 유연하고 재사용성이 높음
* 객체지향 프로그래밍의 기본 원칙을 따름

스프링에서는 POJO를 이용하여 IoC(Inversion of Control)와 DI(Dependency Injection)를 구현합니다. 이를 통해 애플리케이션 개발 시 객체 간의 의존성을 설정하고, 관리할 수
있으며, 테스트 용이성이 향상됩니다. 스프링의 DI 기능을 이용하면, 객체 생성 및 의존성 주입을 자동으로 처리할 수 있습니다. 따라서 개발자는 비즈니스 로직에 집중하여 애플리케이션을 빠르게 개발할 수 있습니다.

## 웹 서비스 개발

### RESTful API란 무엇인가요?

RESTful API는 Representational State Transfer(표현 상태 전이)를 따르는 API입니다. RESTful API는 HTTP 프로토콜을 이용하여, 자원을 이름으로 구분하여 해당 자원의
상태를 주고받는 웹 서비스를 제공합니다. RESTful API는 HTTP 메서드(GET, POST, PUT, DELETE 등)를 이용하여 자원을 조작하며, JSON, XML 등의 데이터 포맷을 이용하여 데이터를
주고받습니다.

RESTful API의 특징은 다음과 같습니다.

* 자원(Resource)을 이름으로 구분하여 조작
* HTTP 메서드(GET, POST, PUT, DELETE 등)를 이용하여 자원 조작
* Stateless(무상태)한 통신 방식
* URI(Uniform Resource Identifier)를 통해 자원을 표현
* JSON, XML 등의 데이터 포맷을 이용하여 데이터를 주고받음

RESTful API는 간결하고 직관적인 API 설계가 가능하며, 다양한 클라이언트(웹, 모바일 등)에서 쉽게 사용될 수 있습니다. 또한, HTTP의 기본적인 기능을 이용하므로 서비스의 확장성과 재사용성이 높습니다.

### 쿠키(Cookie)와 세션(Session)의 차이점은 무엇인가요?

쿠키(Cookie)와 세션(Session)은 웹 브라우저에서 사용되는 개념으로, 사용자의 상태 정보를 유지하기 위해 사용됩니다. 하지만, 쿠키와 세션은 서로 다른 방식으로 정보를 저장하고 처리합니다.

쿠키는 클라이언트(웹 브라우저)에 저장되는 작은 텍스트 파일로, 웹 사이트 방문 기록, 사용자의 로그인 정보, 쇼핑 카트 내용 등을 저장할 수 있습니다. 쿠키는 사용자가 웹 사이트에 접속할 때, 서버에서 클라이언트로
전송됩니다. 그리고, 이후 웹 사이트 방문 시, 클라이언트에서 서버로 쿠키가 전송됩니다. 이를 통해, 클라이언트와 서버 간의 상태 정보를 유지할 수 있습니다.

세션은 클라이언트가 서버에 접속할 때, 서버에서 생성되는 고유한 정보입니다. 세션은 일반적으로 쿠키를 이용하여 클라이언트에게 고유한 ID를 부여하고, 이 ID를 서버에서 관리합니다. 이를 통해, 클라이언트와 서버
간의 상태 정보를 유지할 수 있습니다. 세션은 보안성이 높고, 서버에서 관리하기 때문에 쿠키보다 안전합니다.

쿠키와 세션의 차이점은 다음과 같습니다.

* 저장 위치: 쿠키는 클라이언트에 저장되고, 세션은 서버에 저장됩니다.
* 정보 유지 시간: 쿠키는 만료 기간이 설정되며, 세션은 클라이언트가 로그아웃하거나 브라우저를 종료할 때까지 유지됩니다.
* 보안성: 세션은 서버에서 관리되므로 보안성이 높습니다. 반면, 쿠키는 클라이언트에 저장되므로 상대적으로 보안성이 낮습니다.
* 저장 용량: 쿠키는 저장 용량이 제한되며, 세션은 서버의 용량에 따라 제한됩니다.

쿠키와 세션은 모두 상태 정보를 유지하기 위해 사용되며, 상황에 따라 적절한 방식을 선택하여 사용할 필요가 있습니다.

### 인증(Authentication)과 권한 부여(Authorization)의 차이점은 무엇인가요?

인증(Authentication)과 권한 부여(Authorization)는 웹 시스템에서 보안과 관련된 개념으로, 사용자의 접근을 제어하는 데 사용됩니다. 두 개념은 유사하게 보일 수 있지만, 목적과 처리 방식에
차이가 있습니다.

인증은 사용자의 신원을 확인하는 과정입니다. 인증은 보통 사용자의 ID와 비밀번호를 확인하여, 해당 사용자가 누구인지 확인하는 과정을 의미합니다. 인증 과정을 거친 후에는, 시스템에서 사용자의 신원을 인정하고, 해당
사용자가 시스템에 접근할 수 있도록 합니다.

반면, 권한 부여는 인증된 사용자가 시스템 내의 리소스에 접근할 때, 어떤 작업을 수행할 수 있는지를 결정하는 과정입니다. 권한 부여는 보통 사용자의 역할(Role)이나 그룹(Group) 등의 정보를 확인하여, 해당
사용자가 수행할 수 있는 작업을 결정합니다. 예를 들어, 관리자 권한을 가진 사용자는 시스템의 모든 리소스에 접근할 수 있지만, 일반 사용자는 제한된 리소스에만 접근할 수 있습니다.

요약하면, 인증은 사용자의 신원을 확인하고, 권한 부여는 인증된 사용자가 수행할 수 있는 작업을 결정하는 과정입니다. 인증과 권한 부여는 웹 시스템에서 보안을 유지하고, 안전한 접근을 보장하는 데 중요한 역할을
합니다.

### CI/CD(Continuous Integration/Continuous Deployment)란 무엇인가요?

CI/CD(Continuous Integration/Continuous Deployment)는 소프트웨어 개발 방법론 중 하나로, 소프트웨어 개발과 배포를 지속적으로 자동화하는 방식입니다.

CI/CD는 다음과 같은 단계로 이루어집니다.

Continuous Integration: 개발자가 작성한 코드를 지속적으로 빌드하고, 테스트하는 단계입니다. 이를 통해 코드의 품질을 높이고, 버그를 빠르게 찾아 수정할 수 있습니다.

Continuous Delivery: 빌드된 코드를 지속적으로 배포 가능한 상태로 유지하는 단계입니다. 이를 통해, 언제든지 새로운 버전을 배포할 수 있는 준비 상태를 유지합니다.

Continuous Deployment: Continuous Delivery 단계에서 검증된 코드를 실제 서비스에 자동으로 배포하는 단계입니다.

CI/CD는 소프트웨어 개발 프로세스를 자동화하고, 지속적으로 개발과 배포를 수행함으로써, 개발자와 운영팀 사이의 협업을 강화하고, 효율성을 높이는 데 큰 도움을 줍니다. CI/CD를 적용하면, 개발자는 변경 사항을
자주 통합하고, 빠른 피드백을 받을 수 있으며, 배포도 자동화되므로, 개발과 배포의 시간과 비용을 절감할 수 있습니다.

## 백엔드

### SQL JOIN의 종류에 대해서 설명해주세요.

* INNER JOIN

두 개 이상의 테이블에서 조건에 맞는 레코드만을 반환합니다.
일치하는 레코드가 없으면 반환하지 않습니다.

* LEFT JOIN

왼쪽 테이블의 모든 레코드를 반환하고, 오른쪽 테이블과 조건에 맞는 레코드가 있으면 함께 반환합니다.
조건에 맞는 레코드가 없으면 NULL 값을 반환합니다.

* RIGHT JOIN

오른쪽 테이블의 모든 레코드를 반환하고, 왼쪽 테이블과 조건에 맞는 레코드가 있으면 함께 반환합니다.
조건에 맞는 레코드가 없으면 NULL 값을 반환합니다.

* FULL OUTER JOIN

왼쪽과 오른쪽 테이블 모두에서 조건에 맞는 레코드를 반환합니다.
조건에 맞는 레코드가 없는 경우 NULL 값을 반환합니다.

* CROSS JOIN

두 개 이상의 테이블에서 모든 가능한 조합을 반환합니다.
레코드 수가 많은 경우 결과가 매우 크게 나올 수 있으므로 사용할 때 주의가 필요합니다.

* SELF JOIN

같은 테이블을 여러 번 참조해서 조인합니다.
이를 통해 하나의 테이블에서도 다양한 정보를 추출할 수 있습니다.

### SQL과 NoSQL의 차이점은 무엇인가요?

SQL은 Structured Query Language의 약자로, 관계형 데이터베이스(RDBMS)에서 사용되는 데이터베이스 언어입니다. SQL은 데이터를 테이블 형태로 저장하고, 테이블 간의 관계를 이용하여 데이터를
검색하고 조작합니다.

NoSQL은 Not Only SQL의 약자로, 관계형 데이터베이스 이외의 다양한 형태의 데이터를 저장하고 처리할 수 있는 데이터베이스입니다. NoSQL은 스키마가 없거나 유연한 스키마를 제공하며, 대량의 비정형
데이터 처리에 효과적입니다.

SQL과 NoSQL의 주요 차이점은 다음과 같습니다.

* 데이터 모델: SQL은 테이블 형태의 데이터 모델을 사용하며, NoSQL은 키-값, 문서, 그래프 등 다양한 데이터 모델을 사용합니다.
* 스키마: SQL은 정해진 스키마를 가지며, 데이터 입력 전에 스키마가 먼저 정의되어야 합니다. 반면에, NoSQL은 유연한 스키마를 가지며, 데이터 입력 시 스키마가 동적으로 생성될 수 있습니다.
* 확장성: SQL은 수평적 확장이 어렵고, 수직적 확장만 가능합니다. 반면에, NoSQL은 수평적 확장이 가능하며, 대용량 데이터 처리에 효과적입니다.

### 데이터베이스(Database) 정규화(Normalization)란 무엇인가요?

데이터베이스 정규화는 데이터의 중복을 제거하고, 데이터의 일관성과 무결성을 유지하기 위한 과정입니다. 데이터베이스 정규화는 주로 관계형 데이터베이스에서 사용되며, 다양한 정규화 단계를 거쳐 데이터를 최적화합니다.

데이터베이스 정규화는 대체로 다음과 같은 절차를 따릅니다.

* 제1정규화: 데이터 중복을 제거하기 위해, 모든 속성이 원자적인 값만 가지도록 테이블을 분리합니다.
* 제2정규화: 제1정규화가 완료된 테이블에서, 부분적 종속성(Partial Dependency)을 제거합니다. 이를 위해, 테이블을 분리하고 외래키를 추가합니다.
* 제3정규화: 제2정규화가 완료된 테이블에서, 이행적 종속성(Transitive Dependency)을 제거합니다. 이를 위해, 테이블을 분리합니다.

데이터베스 정규화는 제4정규화, 제5정규화 등의 단계가 추가적으로 있습니다. 이 단계들은 더욱 복잡한 데이터 구조에서 필요하며, 데이터베이스 구조가 복잡해질수록 적용해야 하는 정규화 단계가 많아집니다.

정규화를 통해 데이터 중복을 제거하고, 데이터의 일관성과 무결성을 유지할 수 있습니다. 그러나, 정규화를 지나치게 진행할 경우 데이터베이스의 성능이 저하될 수 있으므로, 적절한 수준의 정규화를 선택하는 것이
중요합니다.

### 인덱스(Index)란 무엇인가요?

인덱스(Index)는 데이터베이스에서 검색 속도를 높이기 위한 데이터 구조입니다. 인덱스는 테이블 내의 하나 이상의 열(column)을 기준으로 정렬된 데이터 세트로, 데이터를 검색할 때 이를 참조하여 빠르게 검색할
수 있습니다.

인덱스를 사용하면, 데이터베이스에서 데이터를 검색하는 데 소요되는 시간을 줄일 수 있습니다. 인덱스는 주로 WHERE 절, JOIN 절, ORDER BY 절과 같은 SQL 쿼리에서 자주 사용됩니다.

인덱스는 대개 B-Tree, B+Tree, Hash Table 등의 알고리즘을 사용하여 구현됩니다. 그리고, 인덱스는 데이터를 검색하는 데 필요한 시간을 단축시키지만, 데이터베이스의 용량을 늘리고, 데이터
입력/수정/삭제에 소요되는 시간을 증가시킬 수 있습니다. 따라서, 인덱스를 사용할 때는 적절한 대상에 대해 인덱스를 생성하고, 관리하는 것이 중요합니다.

### 트랜잭션(Transaction)이란 무엇인가요?

트랜잭션(Transaction)은 데이터베이스에서 데이터의 무결성과 일관성을 보장하기 위한 작업 단위를 의미합니다. 트랜잭션은 일련의 작업을 하나의 논리적인 작업 단위로 묶어서 처리하는 것으로, 여러 개의 쿼리나
데이터 변경 작업이 하나의 단위로 묶여 원자성을 갖습니다.

트랜잭션은 다음과 같은 특징을 가집니다.

* 원자성(Atomicity): 트랜잭션 내에서 수행되는 모든 작업은 전체가 성공하거나 전체가 실패해야 합니다. 즉, 트랜잭션이 실행되는동안 어떤 이유로든 중단될 경우, 이전 상태로 롤백(Rollback)됩니다.
* 일관성(Consistency): 트랜잭션이 수행되기 전과 후의 데이터베이스 상태가 일관성을 유지해야 합니다. 즉, 트랜잭션이 수행되기 전에 정의된 제약 조건이나 규칙이 트랜잭션 수행 후에도 만족되어야 합니다.
* 격리성(Isolation): 트랜잭션 수행 중에는 다른 트랜잭션에 의해 영향을 받지 않도록 격리되어야 합니다. 이를 통해, 다른 트랜잭션이 동시에 실행되는 경우 발생할 수 있는 문제를 방지할 수 있습니다.
* 지속성(Durability): 트랜잭션이 성공적으로 완료되면, 해당 변경 내용은 영구적으로 저장되어야 합니다.

트랜잭션은 데이터베이스에서 데이터를 안전하게 처리하기 위해 매우 중요합니다. 트랜잭션을 사용하면, 여러 개의 작업 단위가 하나의 논리적인 작업 단위로 묶여, 데이터베이스의 일관성과 무결성을 보장할 수 있습니다.

### ORM(Object-Relational Mapping)이란 무엇인가요?

ORM(Object-Relational Mapping)은 객체와 관계형 데이터베이스 간의 데이터를 매핑하기 위한 기술입니다. ORM은 객체 지향 프로그래밍에서 사용되는 객체와 관계형 데이터베이스에서 사용되는 테이블
간의 차이를 해결하기 위해, 객체와 데이터베이스 간의 매핑을 자동으로 수행합니다.

ORM을 사용하면, 데이터베이스와의 상호작용을 위한 SQL 쿼리를 직접 작성하지 않아도 됩니다. 대신, ORM 프레임워크에서 제공하는 API를 사용하여 객체를 데이터베이스에 저장하고, 검색하고, 갱신할 수 있습니다.

ORM을 사용하면, 개발자는 객체 지향적인 코드를 작성하고, 데이터베이스와의 상호작용에 대한 복잡한 부분을 ORM 프레임워크가 처리하므로, 생산성을 높일 수 있습니다. 또한, ORM을 사용하면 데이터베이스와의
상호작용이 더욱 추상화되므로, 데이터베이스를 변경해도 코드를 변경하지 않아도 됩니다.

### 캐싱(Caching)이란 무엇인가요?

캐싱(Caching)은 빠른 데이터 검색을 위해 자주 사용되는 데이터를 미리 복사해 놓는 것을 말합니다. 캐싱은 데이터의 응답 속도를 높이고, 처리 속도를 개선하기 위해 사용됩니다.

캐싱은 대개 웹 서버와 같은 애플리케이션에서 사용되며, 이를 통해 사용자의 요청에 대한 응답 속도를 높일 수 있습니다. 대표적인 예로는 웹 페이지나 API 응답 결과, 데이터베이스 쿼리 결과 등이 있습니다.

캐싱은 다음과 같은 특징을 가집니다.

* 빠른 응답 속도: 캐시된 데이터는 미리 복사해 놓기 때문에, 데이터 검색 시 원래 데이터베이스에서 검색하는 것보다 빠른 속도를 제공합니다.
* 사용자 경험 개선: 캐시를 사용하면, 사용자는 더 빠른 응답 속도와 함께 더 나은 사용자 경험을 제공받을 수 있습니다.
* 시스템 부하 감소: 캐시를 사용하면, 데이터베이스에 대한 요청 수가 줄어들기 때문에, 시스템 부하가 감소합니다.

그러나, 캐싱을 사용할 때는 데이터의 일관성과 무결성을 유지하는 것이 중요합니다. 캐시된 데이터가 원본 데이터와 다른 경우, 데이터의 무결성이 깨질 수 있으므로, 적절한 캐싱 전략을 수립하고, 관리하는 것이
중요합니다.

### JWT(Json Web Token)란 무엇인가요?

JWT(Json Web Token)는 인터넷에서 정보를 안전하게 전송하기 위한 인증 방식 중 하나입니다. JWT는 JSON 형식으로 데이터를 저장하며, 데이터의 무결성을 보장하기 위해 디지털 서명이 포함됩니다.

JWT는 사용자 인증 정보를 안전하게 전송하기 위해 사용됩니다. 예를 들어, 사용자가 로그인을 하면 서버에서 JWT를 발급하고, 이 JWT를 사용하여 사용자 인증 정보를 안전하게 전송할 수 있습니다. 이후 사용자가
다시 서버에 접속할 때는, JWT를 사용하여 사용자 인증을 확인할 수 있습니다.

JWT는 다음과 같은 구성 요소로 이루어져 있습니다.

* Header: JWT에 대한 메타 정보가 포함됩니다. 대표적인 예로는 알고리즘 정보 등이 있습니다.
* Payload: JWT에 저장될 정보가 포함됩니다. 대표적인 예로는 사용자 ID, 권한 정보 등이 있습니다.
* Signature: JWT의 무결성 을 보장하기 위한 디지털 서명이 포함됩니다. 서명은 Secret Key를 사용하여 생성되며, 이를 통해 JWT가 변조되지 않았는지 검증할 수 있습니다.

JWT는 세션과 유사한 역할을 수행할 수 있지만, 세션과 달리 JWT는 서버의 메모리를 사용하지 않습니다. 따라서, 서버 확장성이 더욱 용이하며, 사용자가 다른 서버로 이동해도 인증 정보를 유지할 수 있습니다.

### 동기(Synchronous)와 비동기(Asynchronous)의 차이점은 무엇인가요?

동기(Synchronous)와 비동기(Asynchronous)는 프로그래밍에서 두 가지 다른 처리 방식을 나타냅니다.

동기(Synchronous) 처리 방식은, 한 작업이 완료될 때까지 다른 작업을 수행하지 않는 방식입니다. 즉, 현재 수행 중인 작업이 완료될 때까지 다음 작업으로 넘어가지 않습니다.

비동기(Asynchronous) 처리 방식은, 한 작업이 완료되지 않아도 다른 작업을 수행할 수 있는 방식입니다. 즉, 현재 수행 중인 작업과 상관없이 다른 작업을 수행할 수 있습니다.

동기 처리 방식은 작업의 순서와 실행 시간을 보장할 수 있으므로, 코드 작성이 간단하고 이해하기 쉽습니다. 그러나, 작업이 끝날 때까지 다른 작업을 수행하지 않기 때문에, 대기 시간이 발생하거나, 작업이 느려지는
문제가 발생할 수 있습니다.

비동기 처리 방식은 작업의 순서와 실행 시간을 보장하지 않으므로, 코드 작성이 복잡하고 이해하기 어렵습니다. 그러나, 작업이 완료될 때까지 다른 작업을 수행할 수 있기 때문에, 대기 시간이나 작업이 느려지는 문제를
방지할 수 있습니다.

### 웹 서버(Web Server)와 애플리케이션 서버(Application Server)의 차이점은 무엇인가요?

웹 서버(Web Server)와 애플리케이션 서버(Application Server)는 모두 클라이언트의 요청에 대한 응답을 제공하는 서버입니다. 그러나, 두 서버 간에는 몇 가지 차이점이 있습니다.

웹 서버(Web Server)는 웹 페이지와 같은 정적인 컨텐츠를 제공하는 서버입니다. 대표적인 예로는 Apache, Nginx, IIS 등이 있습니다. 웹 서버 는 정적인 컨텐츠를 처리하기 때문에, HTML,
CSS, JavaScript와 같은 파일을 처리하는 데 적합합니다. 또한, 웹 서버는 프로그램 실행에 필요한 환경을 제공하지 않으므로, 웹 서버 자체로는 동적인 컨텐츠를 처리할 수 없습니다.

반면에, 애플리케이션 서버(Application Server)는 동적인 컨텐츠를 처리하는 데 적합한 서버입니다. 대표적인 예로는 Tomcat, JBoss, WebLogic, WebSphere 등이 있습니다.
애플리케이션 서버는 웹 서버와 달리, 프로그램 실행에 필요한 환경을 제공하며, 다양한 언어와 프레임워크를 지원합니다.

애플리케이션 서버는 다음과 같은 특징을 가집니다.

* 동적인 컨텐츠 처리: 애플리케이션 서버는 동적인 컨텐츠 처리에 적합하며, 다양한 언어와 프레임워크를 지원합니다.
* 분산 처리: 애플리케이션 서버는 분산 처리를 지원하므로, 서버의 확장성을 높일 수 있습니다.
* 보안 기능: 애플리케이션 서버는 보안 기능을 제공하며, 사용자 인증, 권한 부여, 데이터 암호화 등의 기능을 제공합니다.
* 트랜잭션 처리: 애플리케이션 서버는 트랜잭션 처리를 지원하므로, 데이터 일관성을 유지할 수 있습니다.

따라서, 웹 서버와 애플리케이션 서버는 각각의 역할을 가지며, 서버 환경과 업무에 따라 적절한 서버를 선택하여 사용해야 합니다. 
